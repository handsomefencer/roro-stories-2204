## The FROM instruction below builds our first layer using an official image:
FROM ruby:<%= config['ruby_version'] %>

LABEL maintainer="<%= config['dockerhub_email'] %>"

## This is a rails app so, we will want to add node and yarn. In order for our 
## container to trust yarn as a source, we first need to add yarn's public key. 
## One good way to accomplish this is with apt-key, but apt-key is designed to 
## send output to the terminal and not to stdout, and thus apt-key will send a 
## warning message during the build context. One way to deal with the warning
## is to set an environment variable telling apt-get to be quiet. To do this,
## you'd first write an ENV instruction setting the environment variable, then 
## write the RUN instruction adding the key to the container, and then you'd 
## have to write another ENV instruction unsetting the variable. This would be 
## ugly and inconvenient. Another way to deal with the warning is to just ignore 
## it. There's no shame in that but ignoring it in the build context might 
## condition us to ignore it in other contexts. But what if there was a way to 
## deal with it that allowed you to set that variable just for the build 
## context? Fortunately there is, using the ARG instruction. Variables set with 
## ARG instructions stay in the build context while those set with ENV 
## instructions follow into the container. 

## Use an ARG instruction to set a variable disabling the apt-key warning:
ARG APT_KEY_DONT_WARN_ON_DANGEROUS_USAGE=1

## Add yarn's public key using apt-key:
RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -

## Add yarn to our sources:
RUN echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list


## Build a layer updating the image while adding node and yarn from the source
## above:
RUN apt-get update -qq && apt-get install -y build-essential git nodejs yarn

## We have two directories we'd like to follow from the build context into 
## our containers. APP_HOME is where we'll do most of our work and BUNDLE_PATH 
## is where we want bundler to store our gems.  

## Set APP_HOME and BUNDLE_PATH as using ENV instructions:
ENV APP_HOME /usr/src/app/
ENV BUNDLE_PATH /gems

## Create both as directories to make sure they exist:
RUN mkdir ${APP_HOME}
RUN mkdir ${BUNDLE_PATH}

## Tell Docker to create volumes for our workspace and gems
## so other containers can access them.
VOLUME ${APP_HOME}
VOLUME ${BUNDLE_PATH}

## If we copy our entire app using a single COPY instruction, Docker will build 
## it all as a single new layer. When Docker notices a change to a file, it then 
## has to rebuild the entire layer. This can slow development. One way to speed 
## it back up is to break a single big COPY layer into several smaller ones, 
## with slow-building layers that don't change often underneath smaller, 
## lighter, qucker oens that might change a lot. 

## Set your work directory:
WORKDIR ${APP_HOME}

## Build your big, slow gem layer by first copying your Gemfile && Gemfile.lock:  
COPY Gemfile* ./ 
COPY package.json ./ 

## build the bundle layer, which now only runs if your Gemfile changes:
RUN bundle 

## Now build a layer layer with everything in your app that's likely to change
## frequently. If you make a change to any of these files, only this layer has
## to rebuild. smaller, lighter layer
COPY . ${APP_HOME}


COPY roro/docker-entrypoint.sh /usr/bin/docker-entrypoint.sh
RUN chmod +x /usr/bin/docker-entrypoint.sh
ENTRYPOINT ["/usr/bin/docker-entrypoint.sh"]




